#!/usr/bin/env python3

# zxngdefmt



__version__ = "0.1"



import re
import sys



# --- constants ---



# document-level commands
#
# This defines the order in which the commands are written in an output
# guide, as well as to construct the regular expression of commands to
# match.

DOC_CMDS = [
    "title",
    "author",
    "copyright",
    "version",
    "date",
    "build",
    "index",
]


# <?>_RE = string
#
# Regular expressions to match various bits of NextGuide markup.


# link to another node
LINK_RE = r'@{ *"(?P<text>[^"]+)" LINK [^ }]+ *}'

# formatting attribute
ATTR_RE = r"@{\w+}"

# literal characters
LITERALTOKEN_RE = "@(?P<char>[^{])"

# plain (unformatted) word (as opposed to markup)
WORD_RE = "[^@ ]+"

# one or more spaces
SPACE_RE = " +"

# match any type of markup token or word or block of spaces
TOKEN_RE = (r"(?P<token>"
            + LINK_RE
            + r'|' + ATTR_RE
            + r'|' + LITERALTOKEN_RE
            + r'|' + WORD_RE
            + r'|' + SPACE_RE
            + r')'
            + r"(?P<remainder>.*)")

# matching document-level tokens
DOC_CMDS_RE = (r"@(?P<cmd>" + '|'.join(DOC_CMDS) + r")( (?P<value>.+))?")

# start of a node
NODE_CMDS_RE = r"@node (?P<name>\S+)"

# matching a linked node token (for constructing node links)
NODAL_CMDS_RE = r"@(?P<link>(node|prev|next|toc)) (?P<name>\S+)"

# lines to ignore:
#
# - a token with hyphens (a separator between nodes), or
#
# - a remark command
IGNORE_RE = r"@(-+|rem\s)"


# LITERALLINE_RE = string
#
# Regular expression to match lines which must be included in the output
# guide literally (i.e. without reformatting).  Includes:

LITERALLINE_RE = (
    r'('

    # lines with leading spaces
    + r"\s+"

    # lines with 3 or more consecutive spaces
    + r"|.+\s{3,}"

    # lines beginning with '@' but not '@@', '@{' or '@(' (copyright) -
    # these indicate node names, lines to adjacent pages or
    # TOC/index pages
    + r"|@[^{@()]"

    # lines with centred or right-justified text
    + r"|@{[cr]}"

    # lines with headers
    + r"|.*@{h\d}"

    # lines consisting solely of a single link
    + r'|' + LINK_RE + r'$'

    + r')')


# maximum length for a single line in the output guide
#
# we lower this to 78 as there is a bug in NextGuide when links end at
# column 79 or greater; ideally we would detect those as a special, but
# that's something for later
#
# https://gitlab.com/thesmog358/tbblue/-/issues/127

LINE_MAXLEN = 78



# --- functions ---



def render_token(t):
    """Render a NextGuide token (which could be markup, or a literal
    word, or block of spaces) into the text that would be displayed on
    screen (ignoring formatting).  This is used to work out the length
    of rendered markup and calculate displayed line lengths; it is not
    used to generate output.
    """

    # if the token is a link, use the displayed text field
    m = re.match(LINK_RE, t)
    if m:
        return m["text"]

    # if the token is a literal character, convert that to the displayed
    # character
    m = re.match(LITERALTOKEN_RE, t)
    if m:
        c = m["char"]

        # '@(' is the copyright sign
        if c == "(":
            return "\N{COPYRIGHT SIGN}"

        else:
            return c

    # attribute formatting codes don't render to anything displayed
    m = re.match(ATTR_RE, t)
    if m:
        return ""

    # we have a literal word or block of spaces - just use that directly
    return t



class GuideLine(object):
    """This class represents a line being built in a NextGuide, handling
    wrapping of lines at the maximum length (screen width).

    It allows a line to be assembled with appendtoken() for
    non-whitespace tokens.

    When a word (a sequence of non-whitespace tokens) is completed with
    a whitespace token, completeword() is called to determine if that
    word will fit on the current line.  If yes, it will be appended; if
    no, the line will be completed and new one begun with the word.
    """

    def __init__(self):
        super().__init__()

        # initialise the current line, word and precedind whitespace to
        # empty

        self._line_markup = ""
        self._line_render = ""

        self._word_markup = ""
        self._word_render = ""

        self._pre_space = ""


    def write(self):
        """If there is anything in it, write the current line buffer out
        and clear it, ready for the next line.
        """

        # if there is anything in the current line, store it to return
        # and clear them out, ready for the next line
        if self._line_markup:
            line = self._line_markup

            self._line_markup = ""
            self._line_render = ""
            self._pre_space = ""

            return line

        # the current line is empty - just return None
        return None


    def completeword(self, *, space=""):
        """Complete the current word, with the specified block of
        whitespace following it.  If this finishes the current line,
        that is returned.

        If the rendered word, and the stored whitespace from the
        previous call to completeword(), would fit on the line currently
        being built, it is appended and the whitespace supplied here
        will be stored, ready for the next call to completeword().

        If the stored whitespace and word would NOT fit on the fit on
        the current line, the line so far is returned and the stored
        whitespace is discarded (as it is between lines).  A new line is
        begun with a word, and the whitespace supplied here stored.
        """

        # if no line or word, we have nothing to complete nor return, so
        # just return None
        if (not self._line_render) and (not self._word_render):
            return None

        # start with no completed line to return and check if the stored
        # space and rendered word would fit on this line
        line = None
        if (len(self._line_render + self._pre_space + self._word_render)
                > LINE_MAXLEN):

            # adding the current word would make it over length - render it
            line = self.write()

            # don't add the space, as we're beginning a new line

        else:
            # the current word will fit on this line - add the space, as
            # we're continuing the line
            self._line_markup += self._pre_space
            self._line_render += self._pre_space

        # add the current word to the line (either freshly cleared, or
        # continuing the current one)
        self._line_markup += self._word_markup
        self._line_render += self._word_render

        # start a new word with the supplied previous space
        self._word_markup = ""
        self._word_render = ""
        self._pre_space = space

        # return a the compeleted line, if we did that, or None if we
        # are still working on it
        return line


    def appendtoken(self, t):
        """Append the supplied non-whitespace token to the current word.
        """

        self._word_markup += t
        self._word_render += render_token(t)



class GuideNodeRaw(object):
    """A raw node (page in a NextGuide) document.

    TODO
    """


    def __init__(self, name):
        """Initialise a new node with the specified name.
        """

        super().__init__()

        # initialise the current node with the specified name
        self.name = name

        # no links to other documents yet
        self._links = {}

        # no lines yet
        self._lines = []


    def setlink(self, link, node):
        """Unconditionally set the link to another node.  This is used
        when a node explicitly sets the link.
        """

        self._links[link] = node


    def setdefaultlink(self, link, node):
        """Set the link to another node only if this link is not yet
        defined.  This used when the entire document is completed and
        the missing links are filled in.
        """

        if node:
            self._links.setdefault(link, node)


    def getlink(self, link):
        """Return the link to the specified target from this node, or
        None if it is not defined.
        """

        return self._links.get(link)


    def appendline(self, l):
        """Add a raw line to the current node.
        """

        self._lines.append(l)


    def write(self):
        """Render the current node.

        TODO -- replace with getlines() or something as raw data will
        need rendering.
        """

        lines = ["@node " + self.name]

        for link in ["prev", "next", "toc", "index"]:
            if link in self._links:
                lines.append(f"---> @{link} {self._links[link]}")

        for l in self._lines:
            lines.append(l)

        return '\n'.join(lines)



class GuideNode(object):
    """A node (page in a NextGuide) document.
    """


    def __init__(self, name):
        """Initialise a new node with the specified name.
        """

        super().__init__()

        # initialise the current node with the specified name
        self.name = name

        # no links to other documents yet
        self._links = {}

        # no lines yet
        self._lines = []


    def setlink(self, link, node):
        """Unconditionally set the link to another node.  This is called
        when a node explicitly sets the link.
        """

        if not node:
            del self._links[link]
        else:
            self._links[link] = node


    def setdefaultlink(self, link, node):
        """Set the link to another node only if this link is not yet
        defined.  This called when a node is completed, to fill in any
        missing links.
        """
        if node:
            self._links.setdefault(link, node)


    def getlink(self, link):
        """Return the link to the specified target from this node, or
        None if it is not defined.
        """

        return self._links.get(link)


    def appendline(self, l):
        """Add a line to the current node.
        """

        self._lines.append(l)


    def write(self):
        """Render the current node.
        """

        lines = ["@node " + self.name]

        for link in ["prev", "next", "toc", "index"]:
            if link in self._links:
                lines.append(f"@{link} {self._links[link]}")

        for l in self._lines:
            lines.append(l)

        return '\n'.join(lines)



class GuideDocRaw(object):
    """Class representing an entire NextGuide document.

    TODO
    """


    def __init__(self, filename=None):
        """Initialise a new raw document object, optionally reading in a
        source guide file.
        """

        super().__init__()

        # initialise the document
        self._cmds = {}
        self._nodes = []

        # initialise a list of warnings encountered when building the
        # document
        self._warnings = []

        # if a filename was supplied, read it
        if filename:
            self.readfile(filename)


    def readfile(self, filename):
        """Read a source NextGuide file and store it as a raw document.

        TODO
        """


        current_node = None

        with open(filename) as f:
            for l in f:
                # strip any trailing whitespace
                l = l.rstrip()

                # skip lines we want to ignore
                if re.match(IGNORE_RE, l):
                    continue

                # try to match document-level commands
                m = re.match(DOC_CMDS_RE, l)
                if m:
                    if current_node:
                        self._warnings.append("node: @" + current_node.name
                                              + " has document token: " + l
                                              + " - ignored")

                    self._cmds[m.group("cmd")] = m.group("value")
                    continue

                m = re.match(NODE_CMDS_RE, l)
                if m:
                    if current_node:
                        self._nodes.append(current_node)
                    current_node = GuideNodeRaw(m.group("name"))
                    continue

                m = re.match(NODAL_CMDS_RE, l)
                if m:
                    current_node.setlink(*m.group("link", "name"))
                    continue

                # a line of text in the node

                current_node.appendline(l)
                continue


    def getwarnings(self):
        """Returns the list of warnings encountered when building the
        document.  The list will be empty if there were no warnings.
        """

        return self._warnings


    def print(self):
        """TODO - just print the document and nodes raw
        """
        for c in DOC_CMDS:
            if c in self._cmds:
                print(f"@{c}"
                      + (f" {self._cmds[c]}" if c in self._cmds else ""))

        for n in self._nodes:
            print()
            print(n.write())



class GuideDoc(object):
    """Class representing an entire NextGuide document.
    """

    def __init__(self):
        super().__init__()

        # document-level lines (appear before all nodes)
        self._doc_lines = []

        # list of GuideNodes() making up the doc
        self._nodes = []

        # the current node (created when '@node ...' is parsed)
        self._current_node = None

        # current line
        self._current_line = GuideLine()


    def parse(self, f):
        """Parse file into document.
        """

        for l in f:
            # remove any trailing whitespace
            l = l.rstrip()

            #print("LINE -- <", l)

            # skip any lines to ignore
            if re.match(IGNORE_RE, l):
                continue

            if re.match(DOC_RE, l):
                if self._current_node:
                    raise AssertionError("document-level token in node")
                self._doc_lines.append(l)
                continue

            # try and match a node/link token
            m = re.match(NODE_RE, l)
            if m:
                link, node = m.group("link", "node")

                # is this a new node?
                if link == 'node':
                    # finish the current line and append it
                    p = self._current_line.write()
                    if p:
                        self._current_node.appendline(p)

                    # append the current node, if there is one
                    if self._current_node:
                        self._nodes.append(self._current_node)

                    # start a new node
                    self._current_node = GuideNode(node)

                else:
                    # set the link for the node we're constructing
                    self._current_node.setlink(link, node)

                continue

            # if the line is blank or is one that is used literally,
            # just add that to the document
            if (l == '') or re.match(LITERALLINE_RE, l):
                # finish the current line and append it
                p = self._current_line.write()
                if p:
                    self._current_node.appendline(p)

                # add the literal line
                self._current_node.appendline(l)

                continue

            # go through the line matching tokens (markup, literal or spaces)
            while l:
                m = re.match(TOKEN_RE, l)

                if not m:
                    raise AssertionError("something has gone wrong"
                                         f" matching: '{l}'")

                token, l = m.group("token", "remainder")
                #print(f"TOKEN >>> <{token}>")
                #print(f"REMAINDER >>> <{l}>")

                # this token is a space, complete the current word
                if re.match(SPACE_RE, token):
                    p = self._current_line.completeword(space=token)
                    if p:
                        self._current_node.appendline(p)

                else:
                    self._current_line.appendtoken(token)

            # end of line completes a word and adds a space
            p = self._current_line.completeword(space=" ")
            if p:
                self._current_node.appendline(p)

        # if there is something in the buffer
        self.complete_doc()


    def print(self):
        """Print the lines in the current document.
        """

        for l in self._doc_lines:
            print(l)

        for n in self._nodes:
            print('@' + ('-' * (LINE_MAXLEN - 1)))
            print(n.write())


    def complete_doc(self):
        """Finish the entire document.  This will render out of any
        pending data in the line buffer.
        """

        # fill in missing previous node, toc and index nodes
        #
        # prev = whatever the previous node was
        #
        # toc = the most recently defined toc
        #
        # index = the most recently defined index
        prev_node = None
        toc_node = None
        index_node = None
        for node in self._nodes:
            # set missing links for this node
            node.setdefaultlink("prev", prev_node)
            node.setdefaultlink("toc", toc_node)
            node.setdefaultlink("index", index_node)

            # store the information about this node to use for
            # subsequent ones, if defined
            prev_node = node.name
            toc_node = node.getlink("toc")
            index_node = node.getlink("index")

        next_node = None
        for node in reversed(self._nodes):
            node.setdefaultlink("next", next_node)
            next_node = node.name

        p = self._current_line.write()
        if p:
            self._current_node.appendline(p)


rawdoc = GuideDocRaw("NextBASIC.gde")

w = rawdoc.getwarnings()
if w:
    print("Warnings:")
    for w1 in w:
        print('-', w1)

rawdoc.print()

if False:
    doc = GuideDoc()

    with sys.stdin as f:
        doc.parse(f)

    doc.print()
